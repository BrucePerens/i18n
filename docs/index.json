{"repository_name":"i18n","body":"# i18n for the Crystal programming language\n\nUsage\n-----\n\n```\n  include I18n\n\n  t \"Any string.\" # => \"translated string\"\n```\n\nTranslate a `String`, even an **interpolated string**. Check that a\ntranslation for each string, into each language, exists at compile time,\nand abort compilation with an error if one does not. Work-in-progress\ntranslations can indicate that a compilation check is not desired.\n\nAn interpolated string is broken up into fixed string segments, and these\nare translated individually.\n\nThe argument must be a constant string (including interpolated strings),\nnot a method, expression, or variable. This is because much of the\ntranslation mechanism runs at compile-time.\n\nWhen the argument `-Demit-translation-strings` is provided to\n`crystal build`,\nthe compiler will emit a table of all of the strings that are provided\nas arguments to the `t()` function, possibly including duplicates.\nThese are written to `STDOUT` using the `Crystal::Macros#p` method.\nThis table can be edited into a translation file by the\nprogrammer, and is intended to be used by a task for generating such\nfiles with machine translation (not yet written).\n\nLanguages are referred to using\n[IETF language tags](https://en.wikipedia.org/wiki/IETF_language_tag) .\nTwo common\nlanguage tags are \"en-US\" for English as spoken in the United States, and\n\"en\" for English not distinguishing where it is spoken.\n\nTranslations are defined in a `NamedTuple` called `Translations`, which\nmust exist in the program. Each\ntranslation is defined as a tuple of a language tag and an inner tuple\ncontaining translations into that language from the native language\nused in the program (the \"coding language\"). Thus, the `Translations`\ntuple looks like this:\n\n```\nTranslations = { # Assuming the coding language tag is \"en-US\"\n  \"en\" => { # English as spoken in most places other than the USA\n    \"the color of money\" => \"the colour of money\",\n  }\n  \"es\" => { # Spanish (not distinguishing Spain or Mexico)\n    \"the color of money\" => \"el color del dinero\"\n  },\n  \"es-MX\" => { # Mexican Spanish\n    \"the color of money\" => \"el color del dinero\"\n  },\n  \"de\" => { # German (not distinguishing Swiss-German, etc.)\n    \"the color of money\" => \"die Farbe des Geldes\",\n  }\n}\n```\n\nA constant `CodingLanguage` must exist in the program, and is set to a\nstring indicating the language used to write the native strings. So it\nwould have the form `CodingLanguage=\"en-US\"`. `CodingLanguage` should\nindicate where it is spoken, thus `\"en-US\"` rather than `\"en\"`.\nThis allows, for example, a translation to correct for\nspelling differences between US English and the English spoken in the\nUnited Kingdom (\"en-GB\").\n\nA variable or method `language_tag` must exist, which is or returns a\nstring for the language tag of the present user. So, this would be of\nthe form `language_tag = \"es\"` for Spanish (not distinguishing Castilian\nor Mexican Spanish).\n\nWork-in-progress language translations are designated by modifying their\nlanguage tag with a `\"wip-` prefix, so that the compiler does not test those\ntranlations for completion. For example, a work-in-progress\ntranslation into Spanish would have the tag `\"wip-es\"`. To test a\nwork-in-progress translation, `language_tag` must be set to the modified\nform. It is possible for a work-in-progress translation and a completed\none to exist to the same language, for example `\"wip-es\"` and `\"es\"`. This\nallows the same source code to work with a working-but-awkward machine\ntranlation while a human translator produces a better version. \n\nNOTE: Complications of Translation\n\nAt some point you will be askng translators to translate your strings\ninto different languages. You will probably start with a machine\ntranslation, but these can not be expected to be correct, especially\nwhere interpolated strings are concerned.\nThere is not an exact one-to-one mapping of words in two languages to the\nsame meaning. Nor can you expect the order of words in a sentence to remain\nthe same, since grammars vary widely between languages.\nThus, a translation of an interpolated string can be awkward. The original\nwriter's assumptions about what belongs before and after any variables or\nexpressions in the string may not carry over to the grammar of the\ntranslated language.\n\nTo delve briefly into just one of the many differences between languages\nthat complicate translation:\nMany languages like English have no grammatical gender for nouns, while\nothers gender nouns male and female, male female and neuter, or common\nand neuter. Some languages group nouns into animate and inanimate forms,\nand some include noun class modifiers which indicate several different\nforms of a noun. Such language differences can\nrequire your translator to make assumptions about what you have\nwritten. The default gender is usually male, which can lead to your\ntranslation being masculinized in ways you did not expect.\n","program":{"html_id":"i18n/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"i18n","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"i18n/I18n","path":"I18n.html","kind":"module","full_name":"I18n","name":"I18n","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"i18n","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"t(string)-macro","html_id":"t(string)-macro","name":"t","doc":"Translate a `String`, even an **interpolated string**. Check that a\ntranslation for each string, into each language, exists at compile time,\nand abort compilation with an error if one does not. Work-in-progress\ntranslations can indicate that a compilation check is not desired.\n\nAn interpolated string is broken up into fixed string segments, and these\nare translated individually.\n\nThe argument must be a constant string (including interpolated strings),\nnot a method, expression, or variable. This is because much of the\ntranslation mechanism runs at compile-time.\n\nWhen the argument `-Demit-translation-strings` is provided to\n`crystal build`,\nthe compiler will emit a table of all of the strings that are provided\nas arguments to the `t()` function, possibly including duplicates.\nThese are written to `STDOUT` using the `Crystal::Macros#p` method.\nThis table can be edited into a translation file by the\nprogrammer, and is intended to be used by a task for generating such\nfiles with machine translation (not yet written).\n\nLanguages are referred to using\n[IETF language tags](https://en.wikipedia.org/wiki/IETF_language_tag) .\nTwo common\nlanguage tags are \"en-US\" for English as spoken in the United States, and\n\"en\" for English not distinguishing where it is spoken.\n\nTranslations are defined in a `NamedTuple` called `Translations`, which\nmust exist in the program. Each\ntranslation is defined as a tuple of a language tag and an inner tuple\ncontaining translations into that language from the native language\nused in the program (the \"coding language\"). Thus, the `Translations`\ntuple looks like this:\n\n```\nTranslations = { # Assuming the coding language tag is \"en-US\"\n  \"en\" => { # English as spoken in most places other than the USA\n    \"the color of money\" => \"the colour of money\",\n  }\n  \"es\" => { # Spanish (not distinguishing Spain or Mexico)\n    \"the color of money\" => \"el color del dinero\"\n  },\n  \"es-MX\" => { # Mexican Spanish\n    \"the color of money\" => \"el color del dinero\"\n  },\n  \"de\" => { # German (not distinguishing Swiss-German, etc.)\n    \"the color of money\" => \"die Farbe des Geldes\",\n  }\n}\n```\n\nA constant `CodingLanguage` must exist in the program, and is set to a\nstring indicating the language used to write the native strings. So it\nwould have the form `CodingLanguage=\"en-US\"`. `CodingLanguage` should\nindicate where it is spoken, thus `\"en-US\"` rather than `\"en\"`.\nThis allows, for example, a translation to correct for\nspelling differences between US English and the English spoken in the\nUnited Kingdom (\"en-GB\").\n\nA variable or method `language_tag` must exist, which is or returns a\nstring for the language tag of the present user. So, this would be of\nthe form `language_tag = \"es\"` for Spanish (not distinguishing Castilian\nor Mexican Spanish).\n\nWork-in-progress language translations are designated by modifying their\nlanguage tag with a `\"wip-` prefix, so that the compiler does not test\nthose translations for completion. For example, a work-in-progress\ntranslation into Spanish would have the tag `\"wip-es\"`. To test a\nwork-in-progress translation, `language_tag` must be set to the modified\nform. It is possible for a work-in-progress translation and a completed\none to exist to the same language, for example `\"wip-es\"` and `\"es\"`. This\nallows the same source code to work with a working-but-awkward machine\ntranlation while a human translator produces a better version. \n\nNOTE: Complications of Translation\n\nAt some point you will be askng translators to translate your strings\ninto different languages. You will probably start with a machine\ntranslation, but these can not be expected to be correct, especially\nwhere interpolated strings are concerned.\nThere is not an exact one-to-one mapping of words in two languages to the\nsame meaning. Nor can you expect the order of words in a sentence to remain\nthe same, since grammars vary widely between languages.\nThus, a translation of an interpolated string can be awkward. The original\nwriter's assumptions about what belongs before and after any variables or\nexpressions in the string may not carry over to the grammar of the\ntranslated language.\n\nTo delve briefly into just one of the many differences between languages\nthat complicate translation:\nMany languages like English have no grammatical gender for nouns, while\nothers gender nouns male and female, male female and neuter, or common\nand neuter. Some languages group nouns into animate and inanimate forms,\nand some include noun class modifiers which indicate several different\nforms of a noun. Such language differences can\nrequire your translator to make assumptions about what you have\nwritten. The default gender is usually male, which can lead to your\ntranslation being masculinized in ways you did not expect.","summary":"<p>Translate a <code>String</code>, even an <strong>interpolated string</strong>.</p>","abstract":false,"args":[{"name":"string","doc":null,"default_value":"","external_name":"string","restriction":""}],"args_string":"(string)","source_link":null,"def":{"name":"t","args":[{"name":"string","doc":null,"default_value":"","external_name":"string","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    (break_up(\n{{ string }}\n))\n  \n"}}],"types":[]}]}}